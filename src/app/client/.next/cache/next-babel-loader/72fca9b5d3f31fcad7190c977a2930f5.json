{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport styled from 'styled-components';\nimport gq from '../api/gq';\nimport debounce from \"lodash.debounce\";\n\nconst InfiniteBox = props => {\n  const {\n    title,\n    className,\n    createQuery,\n    pageSize,\n    itemComponent: ItemComponent\n  } = props;\n  const [items, setItems] = React.useState([]);\n  const [isLoading, setIsLoading] = React.useState(false);\n\n  const loadMore = () => {\n    setIsLoading(true);\n    gq(createQuery(items.length, pageSize)).then(response => {\n      const {\n        items: newItems\n      } = response;\n      const a = [...items, ...newItems];\n      console.log(a);\n      setItems(a);\n      setIsLoading(false);\n    });\n  };\n\n  React.useEffect(() => {\n    loadMore();\n  }, [1]);\n  React.useEffect(() => {\n    if (isLoading) {\n      window.onscroll = undefined; // we are not going to listen to scroll while items are loading\n    } else {\n      window.onscroll = debounce(() => {\n        if (window.innerHeight + document.documentElement.scrollTop === document.documentElement.offsetHeight) {\n          loadMore();\n        }\n      }, 100);\n    }\n  }, [items.length, isLoading]); // onScroll will change when: items.length is different or isLoading has changed \n\n  return __jsx(\"section\", {\n    className: className\n  }, __jsx(\"h3\", null, title), __jsx(\"div\", {\n    className: \"items\"\n  }, items.map((item, index) => __jsx(ItemComponent, _extends({\n    key: index\n  }, item)))), __jsx(\"div\", {\n    className: \"loader\"\n  }));\n};\n\nexport default styled(InfiniteBox).withConfig({\n  displayName: \"InfiniteBox\",\n  componentId: \"xucww1-0\"\n})([\".items{width:100%;display:grid;grid-template-columns:1fr;grid-gap:15px;@media (min-width:300px){grid-template-columns:repeat(2,1fr);grid-gap:17px;}@media (min-width:768px){grid-template-columns:repeat(3,1fr);grid-gap:15px;}@media (min-width:1024px){grid-template-columns:repeat(4,1fr);grid-gap:20px;}@media (min-width:1624px){grid-template-columns:repeat(5,1fr);grid-gap:30px;}}\"]);","map":{"version":3,"sources":["/Users/vladislavzhabinsky/coding/job-applications/telia/app/client/components/InfiniteBox.tsx"],"names":["React","styled","gq","debounce","InfiniteBox","props","title","className","createQuery","pageSize","itemComponent","ItemComponent","items","setItems","useState","isLoading","setIsLoading","loadMore","length","then","response","newItems","a","console","log","useEffect","window","onscroll","undefined","innerHeight","document","documentElement","scrollTop","offsetHeight","map","item","index"],"mappings":";;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AACA,OAAOC,EAAP,MAAe,WAAf;AACA,OAAOC,QAAP,MAAqB,iBAArB;;AAoBA,MAAMC,WAAW,GAAIC,KAAD,IAAkB;AACrC,QAAM;AAAEC,IAAAA,KAAF;AAAQC,IAAAA,SAAR;AAAkBC,IAAAA,WAAlB;AAA8BC,IAAAA,QAA9B;AAAuCC,IAAAA,aAAa,EAAEC;AAAtD,MAAwEN,KAA9E;AACA,QAAM,CAACO,KAAD,EAAOC,QAAP,IAAmBb,KAAK,CAACc,QAAN,CAAe,EAAf,CAAzB;AACA,QAAM,CAACC,SAAD,EAAWC,YAAX,IAA2BhB,KAAK,CAACc,QAAN,CAAe,KAAf,CAAjC;;AAEA,QAAMG,QAAQ,GAAG,MAAM;AACtBD,IAAAA,YAAY,CAAC,IAAD,CAAZ;AACAd,IAAAA,EAAE,CAACM,WAAW,CAACI,KAAK,CAACM,MAAP,EAAcT,QAAd,CAAZ,CAAF,CACEU,IADF,CACQC,QAAD,IAAmC;AACxC,YAAM;AAAER,QAAAA,KAAK,EAAES;AAAT,UAAsBD,QAA5B;AACA,YAAME,CAAC,GAAG,CAAC,GAAGV,KAAJ,EAAU,GAAGS,QAAb,CAAV;AACAE,MAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACAT,MAAAA,QAAQ,CAACS,CAAD,CAAR;AACAN,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACA,KAPF;AAQA,GAVD;;AAYAhB,EAAAA,KAAK,CAACyB,SAAN,CAAgB,MAAM;AAAER,IAAAA,QAAQ;AAAK,GAArC,EAAsC,CAAC,CAAD,CAAtC;AACAjB,EAAAA,KAAK,CAACyB,SAAN,CAAgB,MAAM;AACrB,QAAGV,SAAH,EAAc;AACbW,MAAAA,MAAM,CAACC,QAAP,GAAkBC,SAAlB,CADa,CACgB;AAC7B,KAFD,MAEO;AACNF,MAAAA,MAAM,CAACC,QAAP,GAAkBxB,QAAQ,CAAC,MAAM;AAChC,YACCuB,MAAM,CAACG,WAAP,GAAqBC,QAAQ,CAACC,eAAT,CAAyBC,SAA9C,KACIF,QAAQ,CAACC,eAAT,CAAyBE,YAF9B,EAGE;AACDhB,UAAAA,QAAQ;AACR;AACD,OAPyB,EAOxB,GAPwB,CAA1B;AAQA;AACD,GAbD,EAaE,CAACL,KAAK,CAACM,MAAP,EAAcH,SAAd,CAbF,EAlBqC,CA+BR;;AAE7B,SACC;AAAS,IAAA,SAAS,EAAER;AAApB,KACC,kBAAKD,KAAL,CADD,EAEC;AAAK,IAAA,SAAS,EAAC;AAAf,KACEM,KAAK,CAACsB,GAAN,CAAU,CAACC,IAAD,EAAMC,KAAN,KACV,MAAC,aAAD;AAAe,IAAA,GAAG,EAAEA;AAApB,KAA+BD,IAA/B,EADA,CADF,CAFD,EAQC;AAAK,IAAA,SAAS,EAAC;AAAf,IARD,CADD;AAYA,CA7CD;;AA+CA,eAAelC,MAAM,CAACG,WAAD,CAArB;AAAA;AAAA;AAAA","sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\nimport gq from '../api/gq';\nimport debounce from \"lodash.debounce\";\n\ninterface CreateQueryFunction {\n\t(skip: number,limit: number): string;\n}\n\ninterface Props {\n\ttitle: string;\n\tpageSize: number;\n\tclassName: string;\n\titemComponent: Function;\n\tcreateQuery: CreateQueryFunction;\n}\n\n// Helped https://alligator.io/react/react-infinite-scroll/\n\ninterface InfiniteBoxResponse {\n\titems: Array<object>;\n}\n\nconst InfiniteBox = (props: Props) => {\n\tconst { title,className,createQuery,pageSize,itemComponent: ItemComponent } = props;\n\tconst [items,setItems] = React.useState([]);\n\tconst [isLoading,setIsLoading] = React.useState(false);\n\n\tconst loadMore = () => {\n\t\tsetIsLoading(true);\n\t\tgq(createQuery(items.length,pageSize))\n\t\t\t.then((response: InfiniteBoxResponse) => {\n\t\t\t\tconst { items: newItems } = response;\n\t\t\t\tconst a = [...items,...newItems];\n\t\t\t\tconsole.log(a);\n\t\t\t\tsetItems(a);\n\t\t\t\tsetIsLoading(false);\n\t\t\t});\n\t};\n\n\tReact.useEffect(() => { loadMore(); },[1]);\n\tReact.useEffect(() => {\n\t\tif(isLoading) {\n\t\t\twindow.onscroll = undefined; // we are not going to listen to scroll while items are loading\n\t\t} else {\n\t\t\twindow.onscroll = debounce(() => {\n\t\t\t\tif(\n\t\t\t\t\twindow.innerHeight + document.documentElement.scrollTop\n\t\t\t\t\t=== document.documentElement.offsetHeight\n\t\t\t\t) {\n\t\t\t\t\tloadMore();\n\t\t\t\t}\n\t\t\t},100);\n\t\t}\n\t},[items.length,isLoading]); // onScroll will change when: items.length is different or isLoading has changed \n\n\treturn (\n\t\t<section className={className}>\n\t\t\t<h3>{title}</h3>\n\t\t\t<div className=\"items\">\n\t\t\t\t{items.map((item,index) => (\n\t\t\t\t\t<ItemComponent key={index} {...item} />\n\t\t\t\t))}\n\t\t\t</div>\n\n\t\t\t<div className=\"loader\"></div>\n\t\t</section>\n\t);\n};\n\nexport default styled(InfiniteBox)`\n\t.items {\n\t\twidth: 100%;\n\t\tdisplay: grid;\n\t\tgrid-template-columns: 1fr;\n\t\tgrid-gap: 15px;\n\t\t@media (min-width: 300px) { grid-template-columns: repeat(2, 1fr); grid-gap: 17px;}\n\t\t@media (min-width: 768px) { grid-template-columns: repeat(3, 1fr); grid-gap: 15px;}\n\t\t@media (min-width: 1024px) { grid-template-columns: repeat(4, 1fr); grid-gap: 20px;}\n\t\t@media (min-width: 1624px) { grid-template-columns: repeat(5, 1fr); grid-gap: 30px;}\n\t}\n`;"]},"metadata":{},"sourceType":"module"}